## MIGEC ANALYSIS REPORT

Below are summary statistics for all MiGEC analysis steps

### Step I: Checkout

This section summarizes the efficiency of sample barcode matching and unique molecular identifier (UMI) extraction

```{r, echo=FALSE, message=FALSE, warning=FALSE}
require(ggplot2); require(reshape);

# load and groom data
df <- read.table("checkout/checkout.log.txt", header=T, comment ="")
df <- df[,3:6]
df[,2:4] <- apply(df[, 2:4], 2, as.numeric)
df[,1] <- as.character(df[, 1])
df <- replace(df, is.na(df), 0)
colnames(df) <- c("sample", "master", "master.and.slave", "overlapped")

# summary
df <- aggregate(cbind(master, master.and.slave, overlapped) ~ sample, data=df, FUN=sum)

#print(df)

nomaster <- df[df$sample=='undef-m',]
noslave <- df[df$sample=='undef-m',]
found <- df[1,]
found[,2:4]<-colSums(df[,2:4])-nomaster[,2:4]-noslave[,2:4]

df.s <-rbind(found, nomaster, noslave)
df.s[,1]<-c('found','no.master','no.master.and.slave')
df.s <- melt(df.s)

df <- df[- grep("undef", df$sample),]
df <- melt(df)
```

**FigI.1**

Overall extraction efficiency

```{r, echo=FALSE, message=FALSE}
ggplot(df.s, aes(x=sample,y=value,fill=variable)) + 
  geom_bar(stat='identity', position='dodge', size = 0.2, colour = "gray30") +
  scale_y_continuous(expand = c(0, 0), limits=c(0,max(df.s$value)*1.2)) + xlab("") + ylab("reads") +
  scale_fill_brewer(palette="Paired") +  
  geom_text(position = position_dodge(width=1), angle=90, size = 3, hjust = -0.1, aes(label=value)) +
  theme_bw()
remove(df.s)
```

**FigI.2**

Distribution of reads recovered by sample

```{r, echo=FALSE, message=FALSE}
ggplot(df, aes(x=sample,y=value,fill=variable)) + 
  geom_bar(stat='identity', position='dodge', size = 0.2, colour = "gray30") + 
  geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=value)) +
  coord_flip() +
  scale_y_log10(expand = c(0, 0), limits=c(1,max(df$value)*10)) + ylab("reads") + xlab("") +
  scale_fill_brewer(palette="Paired") +
  theme_bw()
remove(df)
```

### Step II: Histogram

This section contains data on sequencing depth based on counting the number of reads tagged with the same UMI, i.e. reads that belong to the same Molecular Identifier Group (MIG).

**FigII.1**

Below is the plot of MIG size distribution that was used to select MIG size threshold for assembly (shown by dashed lines).

> Note that the distribution is itself weighted by the number of reads to highlight the mean coverage value and to reflect the percent of reads that will be retained for a given MIG size threshold.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
require(plyr); require(RColorBrewer)

df <- read.table("histogram/overseq.txt", header=T, comment ="")

df.a <- read.table("assemble/assemble.log.txt", header=T, comment ="")
df.a <- aggregate(MIG_COUNT_THRESHOLD ~ X.SAMPLE_ID, data=df.a, FUN=max)
df <- merge(df, df.a, by = "X.SAMPLE_ID")
df$MIG_COUNT_THRESHOLD <- as.character(df$MIG_COUNT_THRESHOLD)

# compute peak values
df$peak <- numeric(nrow(df))

for (i in 1:nrow(df)) {
  df$peak[i] <- which.max(df[i,3:ncol(df)])
}

df$peak <- as.character(df$peak)

# groom data
df <- melt(df, ids = c(X.SAMPLE_ID, SAMPLE_TYPE, peak, MIG_COUNT_THRESHOLD))
df$peak <- as.numeric(df$peak)
df$variable <- as.character(df$variable)
df$variable <- as.numeric(gsub('X', '', df$variable))
df$MIG_COUNT_THRESHOLD <- as.numeric(df$MIG_COUNT_THRESHOLD)
colnames(df) <- c("sample", "sample.type", "threshold", "peak", "mig.size", "count")

# summarize by sample type, normalize within sample
df <- aggregate(count ~ sample + mig.size + threshold + peak, data=df, FUN=sum)
df.n <- ddply(df,.(sample),transform,count=count/sum(count))
df.n$sample <-factor(df.n$sample, levels=df.n[order(df.n$peak), "sample"])

# plotting

pal <- colorRampPalette(brewer.pal(9, "GnBu"))(length(unique(df$sample)))

ggplot(df.n, aes(x=mig.size, color = sample, weight=count)) + 
  geom_vline(aes(xintercept=threshold, color = sample), linetype = "longdash") +
  stat_density(position='identity', adjust = 0.5, size = 0.5, fill = NA) +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  scale_y_continuous(expand=c(0,0)) +
  scale_x_log10(breaks=c(2^(0:7), 512, 2048, 8192, 32768), limits=c(1, 32768), expand=c(0,0)) + 
  ylab("frequency") + xlab("MIG size, reads") + theme_bw() +
  theme(legend.direction ="horizontal",legend.position = "bottom") +
  guides(color=guide_legend(ncol=4))
remove(df)
remove(df.n)
```


### Step III: Assemble

This section contains information on the assembly of MIG consensuses from raw reads 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
require(scales)

df <- read.table("assemble/assemble.log.txt", header=T, comment ="")
df <- data.frame(sample <- df$X.SAMPLE_ID, 
                 migs.assembled <- df$MIGS_GOOD_TOTAL,
                 umi.fraction.assembled <- df$MIGS_GOOD_TOTAL / df$MIGS_TOTAL,
                 reads.fraction.assembled <- df$READS_GOOD_TOTAL / df$READS_TOTAL,
                 reads.dropped.within.mig <- df$READS_DROPPED_WITHIN_MIG / df$READS_GOOD_TOTAL)
df <- aggregate(cbind(migs.assembled, umi.fraction.assembled, reads.fraction.assembled, reads.dropped.within.mig) ~ sample, data=df, FUN=sum)
df$sample <-factor(df$sample, levels=df[order(df$migs.assembled), "sample"])
df <- melt(df)

plotAsm <- function(dd) {
  ggplot(dd, aes(x=sample, fill = sample, y=value)) +
    geom_bar(stat='identity', size = 0.2, colour = "gray30") + 
    geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=round(value*1000)/10)) +
    coord_flip() +    
    scale_fill_manual(values = pal) + guides(fill = F) +
    xlab("") + ylab("") +
    theme_bw()
}
```

**FigIII.1**

Below is a plot showing the total number of assembled MIGs per sample. The number of MIGs should be interpreted as the total number of starting molecules that have been successfully recovered.

```{r, echo=FALSE, message=FALSE}
df.1 <- subset(df, variable == "migs.assembled")
plotAsm(df.1) + scale_y_continuous(expand = c(0, 0), limits=c(0,max(df.1$value)*1.2))
```

**FigIII.2**

Next comes the plot showing the fraction of UMIs that have resulted in assembled consensuses.

> This value is typically low, as it accounts for UMIs filtered due to not passing MIG size threshold. Such UMIs are mostly sequencing errors which generate a high amount of artificial UMI diversity.

```{r, echo=FALSE, message=FALSE}
df.1 <- subset(df, variable == "umi.fraction.assembled")
plotAsm(df.1) + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(df.1$value)*1.2))
```

The fraction of reads contained within assembled MIGs when compared to total number of reads. This number should be high for a high-quality experiment.

**FigIII.3**

```{r, echo=FALSE, message=FALSE}
df.1 <- subset(df, variable == "reads.fraction.assembled")
plotAsm(df.1) + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(df.1$value)*1.2))
```

The fraction of reads that were dropped during consensus assembly. Reads are being dropped if they are found to be substantially different from reads that form the core of consensus sequence. High numbers indicate low sequencing quality and/or presence of library preparation artifacts.

**FigIII.4**

```{r, echo=FALSE, message=FALSE}
df.1 <- subset(df, variable == "reads.dropped.within.mig")
plotAsm(df.1) + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(df.1$value)*1.2))
remove(df.1)
remove(df)
```

### Step IV: CdrBlast

This section contains results of the V(D)J segment mapping and CDR3 extraction algorithm running both for raw and assembled reads.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
df <- read.table("cdrblast/cdrblast.log.txt", header=T, comment ="")

df.m <- data.frame(sample = df$X.SAMPLE_ID, type = df$DATA_TYPE,
                 final.count = df$EVENTS_GOOD, 
                 qual.rate = df$EVENTS_GOOD / df$EVENTS_MAPPED,                 
                 map.rate = df$EVENTS_MAPPED / df$EVENTS_TOTAL)
df.m$metric <- as.factor("mig")
df.m <- df.m[- grep("raw", df.m$type),]
lvl <- df.m[order(df.m$final.count), "sample"]

df.r <- data.frame(sample = df$X.SAMPLE_ID, type = df$DATA_TYPE,
                 final.count = df$READS_GOOD, 
                 qual.rate = df$READS_GOOD / df$READS_MAPPED,
                 map.rate = df$READS_MAPPED / df$READS_TOTAL)
df.r$metric <- as.factor("read")

df <- rbind(df.m, df.r)
df <- melt(df)
df$sample <-factor(df$sample, levels=lvl)

plotCdr.1 <- function(dd) {
  ggplot(dd, aes(x=sample, fill = sample, y=value)) +
    geom_bar(stat='identity', size = 0.2, colour = "gray30") + 
    geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=value)) +
    coord_flip() +
    scale_fill_manual(values = pal) + guides(fill = F) +
    xlab("") + ylab("") + 
    theme_bw()
}

plotCdr.2 <- function(dd) {
  ggplot(dd, aes(x=sample, fill = sample, y=value)) +
    geom_bar(stat='identity', size = 0.2, colour = "gray30") + 
    geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=round(value*1000)/10)) +
    coord_flip() +
    scale_fill_manual(values = pal) + guides(fill = F) +
    xlab("") + ylab("") + 
    theme_bw()
}
```

**FigIV.1**

The plot below shows the total number of MIGs that contain good-quality CDR3 region in assembled reads

```{r, echo=FALSE, message=FALSE}
df.s <- subset(df, variable == "final.count" & type == "asm" & metric == "mig")
plotCdr.1(df.s) + scale_y_continuous(expand = c(0, 0), limits=c(0,max(df.s$value)*1.2))
```

**FigIV.2**

Total number of reads that contain good-quality CDR3 region in raw reads

```{r, echo=FALSE, message=FALSE}
df.s <- subset(df, variable == "final.count" & type == "asm" & metric == "mig")
plotCdr.1(df.s) + scale_y_continuous(expand = c(0, 0), limits=c(0,max(df.s$value)*1.2))
```

**FigIV.3**

Mapping rate, the fraction of reads/MIGs that contain a CDR3 region

> Panels show assembled (**asm**) and unprocessed (**raw**) data. Values are given in number of molecules (**mig**, assembled samples only) and the corresponding read count (**read**)

```{r, echo=FALSE, message=FALSE}
df.s <- subset(df, variable == "map.rate")
plotCdr.2(df.s) + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(df.s$value)*1.2)) + facet_grid(.~type+metric)
```

**FigIV.4**

Good-quality CDR3 sequence rate, the fraction of CDR3-containing reads/MIGs that pass quality filter

> Note that while raw data is being filtered based on Phred quality score, consensus quality score (CQS, the ratio of major variant) is used for assembled data

```{r, echo=FALSE, message=FALSE}
df.s <- subset(df, variable == "qual.rate")
plotCdr.2(df.s) + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(df.s$value)*1.2)) + facet_grid(.~type+metric)
remove(df.s)
remove(df.r)
remove(df.m)
remove(df)
```

### Step V: CdrBlastFitler

This section contains the result of hot-spot error filtering stage, non-functional clonotype filtering (**if enabled**) and final statistics

```{r, echo=FALSE, message=FALSE, warning=FALSE}
nc_filter_enabled <- T
df <- read.table("cdrfinal/cdrblastfilter.log.txt", header=T, comment ="")
df <- data.frame(sample = df$X.SAMPLE_ID, 
                 clones.count = df$CLONOTYPES_TOTAL - 
                   df$CLONOTYPES_FILTERED - ifelse(nc_filter_enabled, df$NON_FUNCTIONAL_CLONOTYPES, 0),
                 migs.count = df$EVENTS_TOTAL - 
                   df$EVENTS_FILTERED - ifelse(nc_filter_enabled, df$NON_FUNCTIONAL_EVENTS, 0),
                 clones.filter.rate = df$CLONOTYPES_FILTERED / df$CLONOTYPES_TOTAL,
                 migs.filter.rate = df$EVENTS_FILTERED / df$EVENTS_TOTAL,
                 clones.nc.rate = df$NON_FUNCTIONAL_CLONOTYPES / df$CLONOTYPES_TOTAL,
                 migs.nc.rate = df$NON_FUNCTIONAL_EVENTS / df$EVENTS_TOTAL
                 )

df$sample <-factor(df$sample, levels=df[order(df$clones.count), "sample"])

plotCdrFinal.1 <- function(dd) {
  ggplot(dd, aes(x=sample, fill = sample, y=value)) +
    geom_bar(stat='identity', size = 0.2, colour = "gray30") + coord_flip() +
    geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=value)) +
    scale_y_continuous(expand = c(0, 0), limits=c(0,max(dd$value)*1.2)) +
    scale_fill_manual(values = pal) + guides(fill = F) +
    xlab("") + ylab("") + 
    theme_bw()
}

plotCdrFinal.2 <- function(dd) {
  ggplot(dd, aes(x=sample, fill = sample, y=value)) +
    geom_bar(stat='identity', size = 0.2, colour = "gray30") + 
    geom_text(position = position_dodge(width=1), size = 3, hjust = -0.1, aes(label=round(value*1000)/10)) +
    coord_flip() +    
    scale_fill_manual(values = pal) + guides(fill = F) +
    xlab("") + ylab("") + facet_grid(.~variable) + 
    theme_bw() + scale_y_continuous(labels = percent_format(), expand = c(0, 0), limits=c(0,max(dd$value)*1.2))
}
```

**FigV.1**

Below is the plot of sample diversity, i.e. the number of clonotypes in a given sample

```{r, echo=FALSE, message=FALSE}
df.1 <- data.frame(sample = df$sample, value = df$clones.count)
plotCdrFinal.1(df.1)
```

**FigV.2**

Total number of molecules (MIGs) in final clonotype tables

```{r, echo=FALSE, message=FALSE}
df.1 <- data.frame(sample = df$sample, value = df$migs.count)
plotCdrFinal.1(df.1)
```

**FigV.3**

Rate of hot-spot error filtering, in terms of clonotypes (**clone** panel) and MIGs (**mig** panel)

```{r, echo=FALSE, message=FALSE}
df.2 <- data.frame(sample = df$sample, mig = df$migs.filter.rate, clone = df$clones.filter.rate)
df.2 <- melt(df.2)
plotCdrFinal.2(df.2)
```

**FigV.4**

Rate of non-coding CDR3 sequences, in terms of clonotypes (**clone** panel) and MIGs (**mig** panel)

```{r, echo=FALSE, message=FALSE}
df.2 <- data.frame(sample = df$sample, mig = df$migs.filter.rate, clone = df$clones.filter.rate)
df.2 <- melt(df.2)
plotCdrFinal.2(df.2)
```
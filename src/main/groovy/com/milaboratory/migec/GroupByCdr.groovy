/*
 * Copyright (c) 2015, Bolotin Dmitry, Chudakov Dmitry, Shugay Mikhail
 * (here and after addressed as Inventors)
 * All Rights Reserved
 *
 * Permission to use, copy, modify and distribute any part of this program for
 * educational, research and non-profit purposes, by non-profit institutions
 * only, without fee, and without a written agreement is hereby granted,
 * provided that the above copyright notice, this paragraph and the following
 * three paragraphs appear in all copies.
 *
 * Those desiring to incorporate this work into commercial products or use for
 * commercial purposes should contact the Inventors using one of the following
 * email addresses: chudakovdm@mail.ru, chudakovdm@gmail.com
 *
 * IN NO EVENT SHALL THE INVENTORS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE INVENTORS HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE INVENTORS HAS
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS. THE INVENTORS MAKES NO REPRESENTATIONS AND EXTENDS NO
 * WARRANTIES OF ANY KIND, EITHER IMPLIED OR EXPRESS, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
 * PARTICULAR PURPOSE, OR THAT THE USE OF THE SOFTWARE WILL NOT INFRINGE ANY
 * PATENT, TRADEMARK OR OTHER RIGHTS.
 */

package com.milaboratory.migec

import com.milaboratory.migec.alignment.CdrReadData

import java.util.zip.GZIPInputStream

import static com.milaboratory.migec.Util.getBLANK_PATH


def W_S = "5", W_M_Q = "15"
def cli = new CliBuilder(usage: "GroupByCdr [options] input.fastq.gz " +
        "(with CDR3 field in header, generated by CdrBlast with --cdr3-fastq-file set) " +
        "[cdr3_filter_table from FilterCdrBlastResults or $BLANK_PATH] output")
cli.h("usage")
cli.f('Quality filter reads with sliding window')
cli._(longOpt: 'window-min-qual', args: 1, "Min average quality in window. Default: $W_M_Q")
cli._(longOpt: 'window-size', args: 1, "Size of sliding window. Default: $W_S")
def opt = cli.parse(args)
if (opt == null || opt.arguments().size() < 3) {
    println "[ERROR] Too few arguments provided"
    cli.usage()
    System.exit(2)
}

if (opt.h) {
    cli.usage()
    System.exit(0)
}

boolean qualFilter = opt.f
int windowSize = Integer.parseInt(opt.'window-size' ?: W_S),
    windowMinQual = Integer.parseInt(opt.'window-min-qual' ?: W_M_Q) * windowSize

def isGoodQual = { String qual ->
    def qualArray = qual.toCharArray().collect { (int) it - 33 }
    int currentQual = 0
    for (int i = 0; i < windowSize; i++)
        currentQual += qualArray[i]

    if (currentQual < windowMinQual)
        return false

    for (int i = windowSize; i < qual.size(); i++) {
        currentQual -= qualArray[i - windowSize]
        currentQual += qualArray[i]

        if (currentQual < windowMinQual)
            return false
    }
    return true
}

def scriptName = getClass().canonicalName
def inputFileName = opt.arguments()[0], outputFileName = opt.arguments()[2]
def cdr3Set = new HashSet<String>()
boolean onlyListedCdrs = opt.arguments()[1] != BLANK_PATH
if (onlyListedCdrs) {
    new File(opt.arguments()[1]).splitEachLine("\t") { line ->
        if (line.size() > 1)
            cdr3Set.add(line[0])
        else
            cdr3Set.add(line[2])
    }
}

def getReader = { String fname ->
    new BufferedReader(new InputStreamReader(fname.endsWith(".gz") ? new GZIPInputStream(new FileInputStream(fname)) :
            new FileInputStream(fname)))
}


def cdrDataMap = new HashMap<String, CdrReadData>()
def reader = getReader(inputFileName)
def header
println "[${new Date()} $scriptName] Reading sequences from $inputFileName"
int n = 0
while ((header = reader.readLine()) != null) {
    def splitHeader = header.split(" ")
    def cdrEntry = splitHeader.find { it.startsWith("CDR3:") }
    if (cdrEntry == null) {
        println "[${new Date()} $scriptName] Error: no CDR3 entry in header: $header. Terminating"
        System.exit(2)
    }
    cdrEntry = cdrEntry.split(":")
    def cdrSeq = cdrEntry[1]
    int cdrFrom = Integer.parseInt(cdrEntry[2])

    if (!onlyListedCdrs || cdr3Set.contains(cdrSeq)) {
        def fullSeq = reader.readLine()
        reader.readLine()
        def qual = reader.readLine()
        if (!qualFilter || isGoodQual(qual)) {
            def cdrReadData = cdrDataMap.get(cdrSeq)
            if (cdrReadData == null)
                cdrDataMap.put(cdrSeq, cdrReadData = new CdrReadData())

            cdrReadData.seqs.add(fullSeq)
            cdrReadData.cdrFroms.add(cdrFrom)
            cdrReadData.minX = Math.min(cdrReadData.minX, cdrFrom)
            cdrReadData.minY = Math.min(cdrReadData.minY, fullSeq.size() - cdrFrom)
        }
    } else {
        reader.readLine()
        reader.readLine()
        reader.readLine()
    }
    n++
}
println "[${new Date()} $scriptName] Finished, $n reads with ${cdrDataMap.size()} unique CDR3 regions."

new File(outputFileName).withPrintWriter { pw ->
    cdrDataMap.each {
        def cdrReadData = it.value
        for (int i = 0; i < it.value.seqs.size(); i++) {
            pw.println(cdrReadData.seqs.size() + "\t" + it.key + "\t" +
                    cdrReadData.seqs[i].substring(cdrReadData.cdrFroms[i] - cdrReadData.minX,
                            cdrReadData.cdrFroms[i] + cdrReadData.minY))
        }
    }
}